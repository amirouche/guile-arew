<h1 id="guile-r7rs">guile-r7rs</h1>
<p><a href="https://builds.sr.ht/~amz3/guile-r7rs?"><img src="https://builds.sr.ht/~amz3/guile-r7rs.svg" alt="builds.sr.ht status" /></a></p>
<h2 id="introduction">Introduction</h2>
<p>guile-r7rs is the collection of libraries part of <a href="https://r7rs.org">R7RS</a> bundled for GNU Guile 2.2 or later.</p>
<h3 id="how-to-contribute">How to contribute</h3>
<ol type="1">
<li><p>Create an account on <a href="https://meta.sr.ht/register">sr.ht</a>. To contribute to existing repository, it is free.</p></li>
<li><p>Pick an item and check nobody is working on it in the <a href="https://todo.sr.ht/~amz3/guile-r7rs">todo</a>.</p></li>
<li><p>Add documentation, tests or an implementation based on existing Guile modules or sample implementation that can be found at <a href="http://srfi.schemers.org/" class="uri">http://srfi.schemers.org/</a>. Also, R7RS small is implemented in terms of R6RS in <a href="https://gitlab.com/akkuscm/akku-r7rs/">akku-r7rs</a> in a compatible license.</p></li>
<li><p>When your contribution is ready, ask amirouche at hyper dev to become a contributor to be able to push.</p></li>
</ol>
<p>Don’t forget to add your name in the license header.</p>
<p>When you add a documentation file, don’t forget to add it to <code>DOCUMENTATION_FILES</code> inside the <code>Makefile</code>. To build the documentation you will need <code>pandoc</code>, <code>latex</code> and to run <code>make doc</code>.</p>
<p>When you add a test file, don’t forget to add it to <code>TESTS_FILES</code> inside <code>Makefile</code>. To run the tests use <code>make check</code>.</p>
<h3 id="table-of-content">Table of Content</h3>
<h4 id="r7rs-small">R7RS small</h4>
<ul>
<li><code>(scheme base)</code></li>
<li><code>(scheme case-lambda)</code></li>
<li><code>(scheme char)</code></li>
<li><code>(scheme complex)</code></li>
<li><code>(scheme cxr)</code></li>
<li><code>(scheme eval)</code></li>
<li><code>(scheme file)</code></li>
<li><code>(scheme inexact)</code></li>
<li><code>(scheme lazy)</code></li>
<li><code>(scheme load)</code></li>
<li><code>(scheme process-context)</code></li>
<li><code>(scheme r5rs)</code></li>
<li><code>(scheme read)</code></li>
<li><code>(scheme repl)</code></li>
<li><code>(scheme time)</code></li>
<li><code>(scheme write)</code></li>
</ul>
<h4 id="r7rs-red-edition">R7RS Red Edition</h4>
<ul>
<li><code>(scheme box)</code> aka. SRFI 111</li>
<li><code>(scheme charset)</code> aka. SRFI 14</li>
<li><code>(scheme comparator)</code> aka. SRFI 128</li>
<li><code>(scheme ephemeron)</code>) aka. SRFI 124</li>
<li><code>(scheme hash-table)</code> aka. SRFI 125</li>
<li><code>(scheme ideque)</code>) aka. SRFI 134</li>
<li><code>(scheme ilist)</code> aka. SRFI 116</li>
<li><code>(scheme list)</code> aka. SRFI 1</li>
<li><code>(scheme list-queue)</code> aka. SRFI 117</li>
<li><code>(scheme lseq)</code> aka. SRFI 127</li>
<li><code>(scheme rlist)</code> aka SRFI 101</li>
<li><code>(scheme set)</code> aka. SRFI 113</li>
<li><code>(scheme sort)</code> aka. SRFI 132</li>
<li><code>(scheme stream)</code> aka. SRFI 41</li>
<li><code>(scheme text)</code> aka. SRFI 135</li>
<li><code>(scheme vector)</code> aka. SRFI 133</li>
</ul>
<h4 id="r7rs-tangerine-edition">R7RS Tangerine Edition</h4>
<ul>
<li><code>(scheme mapping)</code> aka. SRFI 146</li>
<li><code>(scheme mapping hash)</code> aka. SRFI 146</li>
<li><code>(scheme regex)</code> aka. SRFI 115</li>
<li><code>(scheme generator)</code> aka. SRFI 158</li>
<li><code>(scheme division)</code> aka. SRFI 141</li>
<li><code>(scheme bitwise)</code> aka. SRFI 151</li>
<li><code>(scheme fixnum)</code> aka. SRFI 143</li>
<li><code>(scheme flonum)</code> aka. SRFI 144</li>
<li><code>(scheme bytevector)</code> aka. <code>(rnrs bytevectors)</code> aka. SRFI 4</li>
<li><code>(scheme vector @)</code> aka. SRFI 160 where @ is any of base, u8, s8, u16, s16, u32, s32, u64, s64, f32, f64, c64, c128.</li>
<li><code>(scheme show)</code> aka. SRFI 159</li>
</ul>
<h2 id="scheme-base"><code>(scheme base)</code></h2>
<h3 id="section"><code>_</code></h3>
<p>TODO (missing in r7rs?)</p>
<h3 id="section-1"><code>...</code></h3>
<p>It is called ellipsis. It used in macros, <code>match</code> that is not part of R7RS. It signify that a pattern must be repeated.</p>
<h3 id="section-2"><code>=&gt;</code></h3>
<p>TODO</p>
<h3 id="else"><code>else</code></h3>
<p>Used in <code>cond</code> form as in the last clause as a fallback.</p>
<h3 id="number-..."><code>(* number ...)</code></h3>
<p>Multiplication procedure.</p>
<h3 id="number-...-1"><code>(+ number ...)</code></h3>
<p>Addition procedure.</p>
<h3 id="number-...-2"><code>(- number ...)</code></h3>
<p>Substraction procedure.</p>
<h3 id="number-number-..."><code>(/ number number ...)</code></h3>
<p>Division procedure. Raise <code>'numerical-overflow</code> condition in case where denominator is zero.</p>
<h3 id="number-number-...-1"><code>(&lt; number number ...)</code></h3>
<p>Less than procedure. Return a boolean.</p>
<h3 id="number-number-...-2"><code>(&lt;= number number ...)</code></h3>
<p>Less than or equal procedure. Return a boolean.</p>
<h3 id="number-number-...-3"><code>(= number number ...)</code></h3>
<p>Return <code>#t</code> if the numbers passed as parameters are equal. And <code>#f</code> otherwise.</p>
<h3 id="number-number-...-4"><code>(&gt; number number ...)</code></h3>
<p>Greater than procedure. Return a boolean.</p>
<h3 id="number-number-...-5"><code>(&gt;= number number ...)</code></h3>
<p>Greater than or equal. Return a boolean.</p>
<h3 id="abs-number"><code>(abs number)</code></h3>
<p>Return the absolute value of <code>NUMBER</code>.</p>
<h3 id="and-test1-..."><code>(and test1 ...)</code></h3>
<p>The <code>test</code> expressions are evaluated from left to right, and if any expression evaluates to <code>#f</code>, then #f is returned. Any remaining expressions are not evaluated. If all the expressions evaluate to true values, the values of the last expression are returned. If there are no expressions, then <code>#t</code> is returned.</p>
<h3 id="append-lst-..."><code>(append lst ...)</code></h3>
<p>Return the list made of the list passed as parameters in the same order.</p>
<h3 id="apply-proc-arg1-...-args"><code>(apply proc arg1 ... args)</code></h3>
<p>The apply procedure calls proc with the elements of the list <code>(append (list arg1 ...) args)</code> as the actual arguments.</p>
<h3 id="assoc-obj-alist"><code>(assoc obj alist)</code></h3>
<p>Return the first pair which <code>car</code> is equal to <code>OBJ</code> according to the predicate <code>equal?</code>. Or it returns <code>#f</code>.</p>
<h3 id="assq-obj-alist"><code>(assq obj alist)</code></h3>
<p>Return the first pair which <code>car</code> is equal to <code>OBJ</code> according to the predicate <code>eq?</code>. Or it returns <code>#f</code>.</p>
<h3 id="assv-obj-alist"><code>(assv obj alist)</code></h3>
<p>Return the first pair which <code>car</code> is equal to <code>OBJ</code> according to the predicate <code>eqv?</code>. Or it returns <code>#f</code>.</p>
<h3 id="begin-syntax"><code>begin</code> syntax</h3>
<p>There is two uses of <code>begin</code>.</p>
<h4 id="begin-expression-or-definition-..."><code>(begin expression-or-definition ...)</code></h4>
<p>This form of begin can appear as part of a body, or at the outermost level of a program, or at the REPL, or directly nested in a begin that is itself of this form. It causes the contained expressions and definitions to be evaluated exactly as if the enclosing begin construct were not present.</p>
<p>TODO: example</p>
<h4 id="begin-expression1-expression2-..."><code>(begin expression1 expression2 ...)</code></h4>
<p>This form of begin can be used as an ordinary expression. The expressions are evaluated sequentially from left to right, and the values of the last expression are returned. This expression type is used to sequence side effects such as assignments or input and output.</p>
<p>TODO: example</p>
<h3 id="binary-port"><code>binary-port?</code></h3>
<p>TODO: not implemented</p>
<h3 id="boolean-obj-..."><code>(boolean=? obj ...)</code></h3>
<p>Return <code>#t</code> if the scheme objects passed as arguments are the same boolean. Otherwise it return <code>#f</code>.</p>
<h3 id="boolean-obj"><code>(boolean? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is a boolean. Otherwise <code>#f</code>.</p>
<h3 id="bytevector-byte-..."><code>(bytevector byte ...)</code></h3>
<p>Returns a newly allocated bytevector containing its arguments.</p>
<h3 id="bytevector-append-bytevector-..."><code>(bytevector-append bytevector ...)</code></h3>
<p>Returns a newly allocated bytevector whose elements arethe concatenation of the elements in the given bytevectors.</p>
<h3 id="bytevector-copy-bytevector-start-end"><code>(bytevector-copy bytevector [start [end]])</code></h3>
<p>Returns a newly allocated bytevector containing the bytes in bytevector between start and end.</p>
<h3 id="bytevector-copy-to-at-from-start-end"><code>(bytevector-copy! to at from [start [end]])</code></h3>
<p>Copies the bytes of bytevector <code>from</code> between <code>start</code> and <code>end</code> to bytevector <code>TO</code>, starting at <code>at</code>. The order in which bytes are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary bytevector and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<h3 id="bytevector-length-bytevector"><code>(bytevector-length bytevector)</code></h3>
<p>Returns the length of bytevector in bytes as an exact integer.</p>
<h3 id="bytevector-u8-ref"><code>bytevector-u8-ref</code></h3>
<p>Returns the <code>K</code>th byte of <code>BYTEVECTOR</code>. It is an error if <code>K</code> is not a valid index of <code>BYTEVECTOR</code>.</p>
<h3 id="bytevector-u8-set"><code>bytevector-u8-set!</code></h3>
<p>Stores <code>BYTE</code> as the <code>K</code>th byte of <code>BYTEVECTOR</code>.</p>
<p>It is an error if <code>K</code> is not a valid index of <code>BYTEVECTOR</code>.</p>
<h3 id="bytevector-obj"><code>(bytevector? obj)</code></h3>
<p>Returns <code>#t</code> if <code>OBJ</code> is a bytevector. Otherwise, <code>#f</code> is returned.</p>
<h3 id="caar"><code>caar</code></h3>
<p>TODO</p>
<h3 id="cadr"><code>cadr</code></h3>
<p>TODO</p>
<h3 id="call-with-current-continuation-proc"><code>(call-with-current-continuation proc)</code></h3>
<p>It is an error if proc does not accept one argument.</p>
<p>The procedure call-with-current-continuation (or its equivalent abbreviation call/cc) packages the current continuation (see the rationale below) as an “escape procedure” and passes it as an argument to proc. The escape procedure is a Scheme procedure that, if it is later called, will abandon whatever continuation is in effect at that later time and will instead use the continuation that was in effect when the escape procedure was created. Calling the escape procedure will cause the invocation of before and after thunks installed using dynamic-wind.</p>
<p>The escape procedure accepts the same number of arguments as the continuation to the original call to call-with-current-continuation. Most continuations take only one value. Continuations created by the call-with-values procedure (including the initialization expressions of define-values, let-values, and let<em>-values expressions), take the number of values that the consumer expects. The continuations of all non-final expressions within a sequence of expressions, such as in lambda, case-lambda, begin, let, let</em>, letrec, letrec<em>, let-values, let</em>-values, let-syntax, letrec-syntax, parameterize, guard, case, cond, when, and unless expressions, take an arbitrary number of values because they discard the values passed to them in any event. The effect of passing no values or more than one value to continuations that were not created in one of these ways is unspecified.</p>
<p>The escape procedure that is passed to proc has unlimited extent just like any other procedure in Scheme. It can be stored in variables or data structures and can be called as many times as desired. However, like the raise and error procedures, it never returns to its caller.</p>
<p>TODO: example</p>
<h3 id="call-with-port-port-proc"><code>(call-with-port port proc)</code></h3>
<p>The <code>call-with-port</code> procedure calls <code>PROC</code> with <code>PORT</code> as an argument. If <code>PROC</code> returns, then the <code>PORT</code> is closed automatically and the values yielded by the <code>PROC</code> are returned. If <code>PROC</code> does not return, then the <code>PORT</code> must not be closed automatically unless it is possible to prove that the port will never again be used for a read or write operation.</p>
<p>It is an error if <code>PROC</code> does not accept one argument.</p>
<h3 id="call-with-values-producer-consumer"><code>(call-with-values producer consumer)</code></h3>
<p>Calls its producer argument with no arguments and a continuation that, when passed some values, calls the consumer procedure with those values as arguments. The continuation for the call to consumer is the continuation of the call to <code>call-with-values</code>.</p>
<h3 id="callcc"><code>call/cc</code></h3>
<p>Abbreviation for <code>call-with-continuation</code>.</p>
<h3 id="car"><code>car</code></h3>
<p>Returns the contents of the car field ofpair. Note that it is an error to take the <code>car</code> of the empty list.</p>
<h3 id="case-key-clause1-clause2-...-syntax"><code>(case key clause1 clause2 ...)</code> syntax</h3>
<p>TODO</p>
<h3 id="cdar"><code>cdar</code></h3>
<p>TODO</p>
<h3 id="cddr"><code>cddr</code></h3>
<p>TODO</p>
<h3 id="cdr"><code>cdr</code></h3>
<p>Returns the contents of the <code>cdr</code> field of pair. Note that it is an error to take the <code>cdr</code> of the empty list.</p>
<h3 id="ceiling-x"><code>(ceiling x)</code></h3>
<p>The ceiling procedure returns the smallest integer not smaller than x.</p>
<h3 id="char-integer-char"><code>(char-&gt;integer char)</code></h3>
<p>Given a Unicode character, <code>char-&gt;integer</code> returns an exact integer between 0 and #xD7FF or between #xE000 and #x10FFFF which is equal to the Unicode scalar value of that character. Given a non-Unicode character, it returns an exact integer greater than #x10FFFF.</p>
<h3 id="char-ready-port"><code>(char-ready? [port])</code></h3>
<p>Returns #t if a character is ready on the textual input port and returns #f otherwise. If char-ready returns #t then the next read-char operation on the given port is guaranteed not to hang. If the port is at end of file then char-ready? returns #t.</p>
<h3 id="char"><code>char&lt;=?</code></h3>
<p>TODO</p>
<h3 id="char-1"><code>char&lt;?</code></h3>
<p>TODO</p>
<h3 id="char-2"><code>char=?</code></h3>
<p>TODO</p>
<h3 id="char-3"><code>char&gt;=?</code></h3>
<p>TODO</p>
<h3 id="char-4"><code>char&gt;?</code></h3>
<p>TODO</p>
<h3 id="char-5"><code>char?</code></h3>
<p>Returns #t if obj is a character, otherwise returns #f.</p>
<h3 id="close-input-port-port"><code>(close-input-port port)</code></h3>
<p>Closes the resource associated with port, rendering the port incapable of delivering or accepting data.</p>
<h3 id="close-output-port-port"><code>(close-output-port port)</code></h3>
<p>Closes the resource associated with port, rendering the port incapable of delivering or accepting data.</p>
<h3 id="close-port-port"><code>(close-port port)</code></h3>
<p>Closes the resource associated with port, rendering the port incapable of delivering or accepting data.</p>
<h3 id="complex"><code>complex?</code></h3>
<p>Returns #t if obj is a complex number, otherwise returns #f.</p>
<h3 id="cond"><code>cond</code></h3>
<p>TODO</p>
<h3 id="cond-expand"><code>cond-expand</code></h3>
<p>TODO: not implemented</p>
<h3 id="cons-obj1-obj2"><code>(cons obj1 obj2)</code></h3>
<p>Returns a newly allocated pair whose car is obj1 and whose cdr is obj2. The pair is guaranteed to be different (in the sense of eqv?) from every existing object.</p>
<h3 id="current-error-port"><code>current-error-port</code></h3>
<p>Returns the current default error port (an output port). That procedure is also a parameter object, which can be overridden with <code>parameterize</code>.</p>
<h3 id="current-input-port"><code>current-input-port</code></h3>
<p>Returns the current default input port. That procedure is also a parameter object, which can be overridden with <code>parameterize</code>.</p>
<h3 id="current-output-port"><code>current-output-port</code></h3>
<p>Returns the current default output port. That procedure is also a parameter object, which can be overridden with <code>parameterize</code>.</p>
<h3 id="define"><code>define</code></h3>
<p>TODO</p>
<h3 id="define-record-type"><code>define-record-type</code></h3>
<p>TODO</p>
<h3 id="define-syntax"><code>define-syntax</code></h3>
<p>TODO</p>
<h3 id="define-values-var1-...-expr-syntax"><code>(define-values var1 ... expr)</code> syntax</h3>
<p>creates multiple definitions from a single expression returning multiple values. It is allowed wherever define is allowed.</p>
<h3 id="denominator-q"><code>(denominator q)</code></h3>
<p>Return the denominator of their argument; the result is computed as if the argument was represented as a fraction in lowest terms. The denominator is always positive. The denominator of 0 is defined to be 1.</p>
<h3 id="do"><code>do</code></h3>
<p>TODO</p>
<h3 id="dynamic-wind-before-thunk-after"><code>(dynamic-wind before thunk after)</code></h3>
<p>TODO</p>
<h3 id="eof-object"><code>(eof-object)</code></h3>
<p>Returns an end-of-file object, not necessarily unique.</p>
<h3 id="eof-object-obj"><code>(eof-object? obj)</code></h3>
<p>Returns #t if obj is an end-of-file object, otherwise returns #f. A end-of-file object will ever be an object that can be read in using read.</p>
<h3 id="eq-obj1-obj2"><code>(eq? obj1 obj2)</code></h3>
<p>The eq? procedure is similar to eqv? except that in some cases it is capable of discerning distinctions finer than those detectable by eqv?. It must always return #f when eqv? also would, but may return #f in some cases where eqv? would return #t.</p>
<p>On symbols, booleans, the empty list, pairs, and records, and also on non-empty strings, vectors, and bytevectors, eq? and eqv? are guaranteed to have the same behavior. On procedures, eq? must return true if the arguments’ location tags are equal. On numbers and characters, eq?’s behavior is implementation-dependent, but it will always return either true or false. On empty strings, empty vectors, and empty bytevectors, eq? may also behave differently from eqv?.</p>
<h3 id="equal-obj1-obj2"><code>(equal? obj1 obj2)</code></h3>
<p>The equal? procedure, when applied to pairs, vectors, strings and bytevectors, recursively compares them, returning #t when the unfoldings of its arguments into (possibly infinite) trees are equal (in the sense of equal?) as ordered trees, and #f otherwise. It returns the same as eqv? when applied to booleans, symbols, numbers, characters, ports, procedures, and the empty list. If two objects are eqv?, they must be equal? as well. In all other cases, equal? may return either #t or #f.</p>
<p>Even if its arguments are circular data structures, equal? must always terminate.</p>
<h3 id="eqv-obj1-obj2"><code>(eqv? obj1 obj2)</code></h3>
<p>The eqv? procedure defines a useful equivalence relation on objects. Briefly, it returns #t if obj1 and obj2 are normally regarded as the same object.</p>
<p>TODO: complete based on r7rs small and guile.</p>
<h3 id="error-who-message-.-irritants"><code>(error [who] message . irritants)</code></h3>
<p>Raises an exception as if by calling raise on a newly allocated implementation-defined object which encapsulates the information provided by message, as well as any objs, known as the irritants. The procedure error-object? must return #t on such objects.</p>
<h3 id="error-object-irritants-error"><code>(error-object-irritants error)</code></h3>
<p>Returns a list of the irritants encapsulated by error.</p>
<h3 id="error-object-message-error"><code>(error-object-message error)</code></h3>
<p>Returns the message encapsulated by error.</p>
<h3 id="error-object-obj"><code>(error-object? obj)</code></h3>
<p>Returns #t if obj is an object created by <code>error</code> or one of an implementation-defined set of objects. Otherwise, it returns #f. The objects used to signal errors, including those which satisfy the predicates <code>file-error?</code> and <code>read-error?</code>, may or may not satisfy <code>error-object?</code>.</p>
<h3 id="even-number"><code>(even? number)</code></h3>
<p>Return <code>#t</code> if <code>NUMBER</code> is even. Otherwise <code>#f</code>.</p>
<h3 id="exact-z"><code>(exact z)</code></h3>
<p>TODO: FIXME</p>
<p>The procedure exact returns an exact representation of z. The value returned is the exact number that is numerically closest to the argument. For exact arguments, the result is the same as the argument. For inexact non-integral real arguments, the implementation may return a rational approximation, or may report an implementation violation. For inexact complex arguments, the result is a complex number whose real and imaginary parts are the result of applying exact to the real and imaginary parts of the argument, respectively. If an inexact argument has no reasonably close exact equivalent, (in the sense of <code>=</code>), then a violation of an implementation restriction may be reported.</p>
<h3 id="exact-integer-sqrt-k"><code>(exact-integer-sqrt k)</code></h3>
<p>TODO</p>
<h3 id="exact-integer-z"><code>(exact-integer? z)</code></h3>
<p>Returns #t if z is both exact and an integer; otherwise returns #f.</p>
<h3 id="exact-z-1"><code>(exact? z)</code></h3>
<p>Return <code>#t</code> if <code>Z</code> is exact. Otherwise <code>#f</code>.</p>
<h3 id="expt-z1-z2"><code>(expt z1 z2)</code></h3>
<p>Returns <code>z1</code> raised to the power <code>z2</code>.</p>
<h3 id="features"><code>features</code></h3>
<p>TODO: no implemented</p>
<h3 id="file-error-error"><code>(file-error? error)</code></h3>
<p>TODO: not implemented?</p>
<h3 id="floor-x"><code>(floor x)</code></h3>
<p>The floor procedure returns the largest integer not larger than x.</p>
<h3 id="floor-quotient"><code>floor-quotient</code></h3>
<p>TODO</p>
<h3 id="floor-remainder"><code>floor-remainder</code></h3>
<p>TODO</p>
<h3 id="floor"><code>floor/</code></h3>
<p>TODO</p>
<h3 id="flush-output-port-port"><code>(flush-output-port [port])</code></h3>
<p>Flushes any buffered output from the buffer of output-port to the underlying file or device and returns an unspecified value.</p>
<h3 id="for-each-proc-list1-..."><code>(for-each proc list1 ...)</code></h3>
<p>It is an error if proc does not accept as many arguments as there are lists.</p>
<p>The arguments to for-each are like the arguments to map, but for-each calls proc for its side effects rather than for its values. Unlike map, for-each is guaranteed to call proc on the elements of the lists in order from the first element(s) to the last, and the value returned by for-each is unspecified. If more than one list is given and not all lists have the same length, for-each terminates when the shortest list runs out. The lists can be circular, but it is an error if all of them are circular.</p>
<h3 id="gcd-n1-..."><code>(gcd n1 ...)</code></h3>
<p>Return the greatest common divisor.</p>
<h3 id="get-output-bytevector"><code>get-output-bytevector</code></h3>
<p>It is an error if port was not created with open-output-bytevector.</p>
<p>Returns a bytevector consisting of the bytes that have been output to the port so far in the order they were output.</p>
<h3 id="get-output-string-port"><code>(get-output-string port)</code></h3>
<p>It is an error if port was not created with open-output-string.</p>
<p>Returns a string consisting of the characters that have been output to the port so far in the order they were output.</p>
<h3 id="guard"><code>guard</code></h3>
<p>TODO</p>
<h3 id="if-expr-then-else"><code>(if expr then [else])</code></h3>
<p>TODO</p>
<h3 id="include"><code>include</code></h3>
<p>TODO: not implemented?</p>
<h3 id="include-ci"><code>include-ci</code></h3>
<p>TODO: not implemented?</p>
<h3 id="inexact-z"><code>(inexact z)</code></h3>
<p>The procedure inexact returns an inexact representation of z. The value returned is the inexact number that is numerically closest to the argument. For inexact arguments, the result is the same as the argument. For exact complex numbers, the result is a complex number whose real and imaginary parts are the result of applying inexact to the real and imaginary parts of the argument, respectively. If an exact argument has no reasonably close inexact equivalent (in the sense of <code>=</code>), then a violation of an implementation restriction may be reported.</p>
<h3 id="inexact-z-1"><code>(inexact? z)</code></h3>
<p>Return <code>#t</code> if <code>Z</code> is inexact. Otherwise <code>#f</code>.</p>
<h3 id="input-port-open-port"><code>(input-port-open? port)</code></h3>
<p>Returns #t if port is still open and capable of performing input, and #f otherwise.</p>
<h3 id="input-port-obj"><code>(input-port? obj)</code></h3>
<p>Return <code>#t</code> if obj is an input port. Otherwise it return <code>#f</code>.</p>
<h3 id="integer-char-integer"><code>(integer-&gt;char integer)</code></h3>
<p>Given an exact integer that is the value returned by a character when char-&gt;integer is applied to it, integer-&gt;char returns that character.</p>
<h3 id="integer-obj"><code>(integer? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is an integer. Otherwise <code>#f</code>.</p>
<h3 id="lambda"><code>lambda</code></h3>
<p>TODO</p>
<h3 id="lcm-n1-..."><code>(lcm n1 ...)</code></h3>
<p>Return the least common multiple of its arguments.</p>
<h3 id="length-list"><code>(length list)</code></h3>
<p>Returns the length of list.</p>
<h3 id="let"><code>let</code></h3>
<p>TODO</p>
<h3 id="let-1"><code>let*</code></h3>
<p>TODO</p>
<h3 id="let-values"><code>let*-values</code></h3>
<p>TODO</p>
<h3 id="let-syntax"><code>let-syntax</code></h3>
<p>TODO</p>
<h3 id="let-values-1"><code>let-values</code></h3>
<p>TODO</p>
<h3 id="letrec"><code>letrec</code></h3>
<p>TODO</p>
<h3 id="letrec-1"><code>letrec*</code></h3>
<p>TODO</p>
<h3 id="letrec-syntax"><code>letrec-syntax</code></h3>
<p>TODO</p>
<h3 id="list-obj-..."><code>(list obj ...)</code></h3>
<p>Returns a newly allocated list of its arguments.</p>
<h3 id="list-string-list"><code>(list-&gt;string list)</code></h3>
<p>It is an error if any element of list is not a character.</p>
<p>list-&gt;string returns a newly allocated string formed from the elements in the list list.</p>
<h3 id="list-vector-list"><code>(list-&gt;vector list)</code></h3>
<p>The list-&gt;vector procedure returns a newly created vector initialized to the elements of the list list.</p>
<h3 id="list-copy-obj"><code>(list-copy obj)</code></h3>
<p>Returns a newly allocated copy of the given obj if it is a list. Only the pairs themselves are copied; the cars of the result are the same (in the sense of eqv?) as the cars of list. If obj is an improper list, so is the result, and the final cdrs are the same in the sense of eqv?. An obj which is not a list is returned unchanged. It is an error if obj is a circular list.</p>
<h3 id="list-ref-list-k"><code>(list-ref list k)</code></h3>
<p>The list argument can be circular, but it is an error if list has fewer than k elements.</p>
<p>Returns the kth element of list. (This is the same as the car of (list-tail list k).)</p>
<h3 id="list-set-list-k-obj"><code>(list-set! list k obj)</code></h3>
<p>It is an error if k is not a valid index of list.</p>
<p>The list-set! procedure stores obj in element k of list.</p>
<h3 id="list-tail-list-k"><code>(list-tail list k)</code></h3>
<p>It is an error if list has fewer than k elements.</p>
<p>Returns the sublist of list obtained by omitting the first k elements.</p>
<h3 id="list-obj"><code>(list? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is a list. Otherwise <code>#f</code>.</p>
<h3 id="make-bytevector-k-byte"><code>(make-bytevector k [byte])</code></h3>
<p>he make-bytevector procedure returns a newly allocated bytevector of length k. If byte is given, then all elements of the bytevector are initialized to byte, otherwise the contents of each element are unspecified.</p>
<h3 id="make-list-k-fill"><code>(make-list k [fill])</code></h3>
<p>Returns a newly allocated list of k elements. If a second argument is given, then each element is initialized to fill. Otherwise the initial contents of each element is unspecified.</p>
<h3 id="make-parameter-init-converter"><code>(make-parameter init [converter])</code></h3>
<p>Returns a newly allocated parameter object, which is a procedure that accepts zero arguments and returns the value associated with the parameter object. Initially, this value is the value of (converter init), or of init if the conversion procedure converter is not specified. The associated value can be temporarily changed using parameterize, which is described below.</p>
<h3 id="make-string-k-char"><code>(make-string k [char])</code></h3>
<p>The make-string procedure returns a newly allocated string of length k. If char is given, then all the characters of the string are initialized to char, otherwise the contents of the string are unspecified.</p>
<h3 id="make-vector-k-fill"><code>(make-vector k [fill])</code></h3>
<p>Returns a newly allocated vector of k elements. If a second argument is given, then each element is initialized to fill. Otherwise the initial contents of each element is unspecified.</p>
<h3 id="map-proc-list1-..."><code>(map proc list1 ...)</code></h3>
<p>It is an error if proc does not accept as many arguments as there are lists and return a single value.</p>
<p>The map procedure applies proc element-wise to the elements of the lists and returns a list of the results, in order. If more than one list is given and not all lists have the same length, map terminates when the shortest list runs out. The lists can be circular, but it is an error if all of them are circular. It is an error for proc to mutate any of the lists. The dynamic order in which proc is applied to the elements of the lists is unspecified. If multiple returns occur from map, the values returned by earlier returns are not mutated.</p>
<h3 id="max-x1-..."><code>(max x1 ...)</code></h3>
<p>Return the maximum of its arguments.</p>
<h3 id="member-obj-list-compare"><code>(member obj list [compare])</code></h3>
<p>Return the first sublist of list whose <code>car</code> is <code>obj</code>, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If <code>obj</code> does not occur in <code>list</code>, then <code>#f</code> (not the empty list) is returned.</p>
<p>Uses <code>compare</code>, if given, and <code>equal?</code> otherwise.</p>
<h3 id="memq-obj-list"><code>(memq obj list)</code></h3>
<p>Return the first sublist of list whose <code>car</code> is <code>obj</code>, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If <code>obj</code> does not occur in <code>list</code>, then <code>#f</code> (not the empty list) is returned.</p>
<p>Use <code>eq?</code> for comparison.</p>
<h3 id="memv-obj-list"><code>(memv obj list)</code></h3>
<p>Return the first sublist of list whose <code>car</code> is <code>obj</code>, where the sublists of list are the non-empty lists returned by (list-tail list k) for k less than the length of list. If <code>obj</code> does not occur in <code>list</code>, then <code>#f</code> (not the empty list) is returned.</p>
<p>Uses <code>eqv?</code> for comparison.</p>
<h3 id="min-x1-..."><code>(min x1 ...)</code></h3>
<p>Return the minimum of its arguments.</p>
<h3 id="modulo-n1-n2"><code>(modulo n1 n2)</code></h3>
<p><code>modulo</code> is equivalent to <code>floor-remainder</code>. Provided for backward compatibility.</p>
<h3 id="negative-x"><code>(negative? x)</code></h3>
<p>Return <code>#t</code> if <code>X</code> is negative. Otherwise <code>#f</code>.</p>
<h3 id="newline-port"><code>(newline [port])</code></h3>
<p>Writes an end of line to output port.</p>
<h3 id="not-obj"><code>(not obj)</code></h3>
<p>The not procedure returns #t if obj is false, and returns #f otherwise.</p>
<h3 id="null-obj"><code>(null? obj)</code></h3>
<p>Returns #t if obj is the empty list, otherwise returns #f.</p>
<h3 id="number-string-z-radix"><code>(number-&gt;string z [radix])</code></h3>
<p>It is an error if radix is not one of 2, 8, 10, or 16.</p>
<h3 id="number-obj"><code>(number? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is a number. Otherwise <code>#f</code>.</p>
<h3 id="numerator-q"><code>(numerator q)</code></h3>
<p>TODO</p>
<h3 id="odd-number"><code>(odd? number)</code></h3>
<p>Return <code>#t</code> if <code>NUMBER</code> is odd. Otherwise <code>#f</code>.</p>
<h3 id="open-input-bytevector-bytevector"><code>(open-input-bytevector bytevector)</code></h3>
<p>Takes a bytevector and returns a binary input port that delivers bytes from the bytevector.</p>
<h3 id="open-input-string-string"><code>(open-input-string string)</code></h3>
<p>Takes a string and returns a textual input port that delivers characters from the string. If the string is modified, the effect is unspecified.</p>
<h3 id="open-output-bytevector"><code>(open-output-bytevector)</code></h3>
<p>Returns a binary output port that will accumulate bytes for retrieval by <code>get-output-bytevector</code>.</p>
<h3 id="open-output-string"><code>(open-output-string)</code></h3>
<p>Returns a textual output port that will accumulate characters for retrieval by <code>get-output-string</code>.</p>
<h3 id="or-test1-...-syntax"><code>(or test1 ...)</code> syntax</h3>
<p>The <code>test</code> expressions are evaluated from left to right, and the value of the first expression that evaluates to a true value is returned. Any remaining expressions are not evaluated. If all expressions evaluate to #f or if there are no expressions, then #f is returned.</p>
<h3 id="output-port-open-port"><code>(output-port-open? port)</code></h3>
<p>Returns #t if port is still open and capable of performing output, and #f otherwise.</p>
<h3 id="output-port-obj"><code>(output-port? obj)</code></h3>
<p>Return #t if obj is an output port. Otherwise return #f.</p>
<h3 id="pair-obj"><code>(pair? obj)</code></h3>
<p>The pair? predicate returns #t if obj is a pair, and otherwise returns #f.</p>
<h3 id="parameterize-param1-value1-...-expr-..."><code>(parameterize ((param1 value1) ...) expr ...)</code></h3>
<p>A parameterize expression is used to change the values returned by specified parameter objects during the evaluation of the body.</p>
<p>The param and value expressions are evaluated in an unspecified order. The body is evaluated in a dynamic environment in which calls to the parameters return the results of passing the corresponding values to the conversion procedure specified when the parameters were created. Then the previous values of the parameters are restored without passing them to the conversion procedure. The results of the last expression in the body are returned as the results of the entire parameterize expression.</p>
<p>Note: If the conversion procedure is not idempotent, the results of (parameterize ((x (x))) …), which appears to bind the parameter x to its current value, might not be what the user expects.</p>
<p>If an implementation supports multiple threads of execution, then parameterize must not change the associated values of any parameters in any thread other than the current thread and threads created inside body.</p>
<p>Parameter objects can be used to specify configurable settings for a computation without the need to pass the value to every procedure in the call chain explicitly.</p>
<h3 id="peek-char-port"><code>(peek-char [port])</code></h3>
<p>Returns the next character available from the textual input port, but without updating the port to point to the following character. If no more characters are available, an end-of-file object is returned.</p>
<p>Note: The value returned by a call to peek-char is the same as the value that would have been returned by a call to read-char with the same port. The only difference is that the very next call to read-char or peek-char on that port will return the value returned by the preceding call to peek-char. In particular, a call to peek-char on an interactive port will hang waiting for input whenever a call to read-char would have hung.</p>
<h3 id="peek-u8-port"><code>(peek-u8 [port])</code></h3>
<p>Returns the next byte available from the binary input port, but without updating the port to point to the following byte. If no more bytes are available, an end-of-file object is returned.</p>
<h3 id="port-obj"><code>(port? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is port. Otherwise <code>#f</code>.</p>
<h3 id="positive-x"><code>(positive? x)</code></h3>
<p>Return <code>#t</code> if <code>X</code> is positive. Otherwise <code>#f</code>.</p>
<h3 id="procedure-obj"><code>(procedure? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is a procedure. Otherwise <code>#f</code>.</p>
<h3 id="quasiquote"><code>quasiquote</code></h3>
<p>TODO</p>
<h3 id="quote"><code>quote</code></h3>
<p>TODO</p>
<h3 id="quotient"><code>quotient</code></h3>
<p>TODO</p>
<h3 id="raise-obj"><code>(raise obj)</code></h3>
<p>Raises an exception by invoking the current exception handler on obj. The handler is called with the same dynamic environment as that of the call to raise, except that the current exception handler is the one that was in place when the handler being called was installed. If the handler returns, a secondary exception is raised in the same dynamic environment as the handler. The relationship between obj and the object raised by the secondary exception is unspecified.</p>
<h3 id="raise-continuable-obj"><code>(raise-continuable obj)</code></h3>
<p>Raises an exception by invoking the current exception handler on obj. The handler is called with the same dynamic environment as the call to raise-continuable, except that: (1) the current exception handler is the one that was in place when the handler being called was installed, and (2) if the handler being called returns, then it will again become the current exception handler. If the handler returns, the values it returns become the values returned by the call to raise-continuable.</p>
<h3 id="rational-obj"><code>(rational? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is a rational number. Otherwise <code>#f</code>.</p>
<h3 id="rationalize-x-y"><code>(rationalize x y)</code></h3>
<p>The rationalize procedure returns the simplest rational number differing from x by no more than y.</p>
<h3 id="read-bytevector-k-port"><code>(read-bytevector k [port])</code></h3>
<p>Reads the next k bytes, or as many as are available before the end of file, from the binary input port into a newly allocated bytevector in left-to-right order and returns the bytevector. If no bytes are available before the end of file, an end-of-file object is returned.</p>
<h3 id="read-bytevector-bytevector-port-start-end"><code>(read-bytevector! bytevector [port [start [end]]])</code></h3>
<p>Reads the next end - start bytes, or as many as are available before the end of file, from the binary input port into bytevector in left-to-right order beginning at the start position. If end is not supplied, reads until the end of bytevector has been reached. If start is not supplied, reads beginning at position 0. Returns the number of bytes read. If no bytes are available, an end-of-file object is returned.</p>
<h3 id="read-char-port"><code>(read-char [port])</code></h3>
<p>Returns the next character available from the textual input port, updating the port to point to the following character. If no more characters are available, an end-of-file object is returned.</p>
<h3 id="read-error-obj"><code>(read-error? obj)</code></h3>
<p>Error type predicates. Returns #t if obj is an object raised by the read procedure. Otherwise, it returns #f.</p>
<h3 id="read-line-port"><code>(read-line [port])</code></h3>
<p>Returns the next line of text available from the textual input port, updating the port to point to the following character. If an end of line is read, a string containing all of the text up to (but not including) the end of line is returned, and the port is updated to point just past the end of line. If an end of file is encountered before any end of line is read, but some characters have been read, a string containing those characters is returned. If an end of file is encountered before any characters are read, an end-of-file object is returned. For the purpose of this procedure, an end of line consists of either a linefeed character, a carriage return character, or a sequence of a carriage return character followed by a linefeed character. Implementations may also recognize other end of line characters or sequences.</p>
<h3 id="read-string-k-port"><code>(read-string k [port])</code></h3>
<p>Reads the next k characters, or as many as are available before the end of file, from the textual input port into a newly allocated string in left-to-right order and returns the string. If no characters are available before the end of file, an end-of-file object is returned.</p>
<h3 id="read-u8-port"><code>(read-u8 [port])</code></h3>
<p>Returns the next byte available from the binary input port, updating the port to point to the following byte. If no more bytes are available, an end-of-file object is returned.</p>
<h3 id="real-obj"><code>(real? obj)</code></h3>
<p>Return #t if <code>OBJ</code> is real number. Otherwise <code>#f</code>.</p>
<h3 id="remainder-n1-n2"><code>(remainder n1 n2)</code></h3>
<p>TODO</p>
<h3 id="reverse-list"><code>(reverse list)</code></h3>
<p>Returns a newly allocated list consisting of the elements of list in reverse order.</p>
<h3 id="round-x"><code>(round x)</code></h3>
<p>TODO</p>
<h3 id="set-variable-expression-syntax"><code>(set! variable expression)</code> syntax</h3>
<p>Expression is evaluated, and the resulting value is stored in the location to which variable is bound. It is an error if variable is not bound either in some region enclosing the set! expression or else globally. The result of the set! expression is unspecified.</p>
<h3 id="set-car-pair-obj"><code>(set-car! pair obj)</code></h3>
<p>Stores <code>obj</code> in the car field of <code>pair</code>.</p>
<h3 id="set-cdr-pair-obj"><code>(set-cdr! pair obj)</code></h3>
<p>Stores obj in the cdr field of pair.</p>
<h3 id="square-z"><code>(square z)</code></h3>
<p>Returns the square of z. This is equivalent to (* z z).</p>
<h3 id="string-char-..."><code>(string char ...)</code></h3>
<p>Returns a newly allocated string composed of the arguments. It is analogous to list.</p>
<h3 id="string-list-straing-start-end"><code>(string-&gt;list straing [start [end]])</code></h3>
<p>The string-&gt;list procedure returns a newly allocated list of the characters of string between start and end.</p>
<h3 id="string-number-string-radix"><code>(string-&gt;number string [radix])</code></h3>
<p>Returns a number of the maximally precise representation expressed by the given string. It is an error if radix is not 2, 8, 10, or 16.</p>
<p>If supplied, radix is a default radix that will be overridden if an explicit radix prefix is present in string (e.g. “#o177”). If radix is not supplied, then the default radix is 10. If string is not a syntactically valid notation for a number, or would result in a number that the implementation cannot represent, then string-&gt;number returns #f. An error is never signaled due to the content of string.</p>
<h3 id="string-symbol-string"><code>(string-&gt;symbol string)</code></h3>
<p>Returns the symbol whose name is string. This procedure can create symbols with names containing special characters that would require escaping when written, but does not interpret escapes in its input.</p>
<h3 id="string-utf8-string-start-end"><code>(string-&gt;utf8 string [start [end]])</code></h3>
<p>The string-&gt;utf8 procedure encodes the characters of a string between start and end and returns the corresponding bytevector.</p>
<h3 id="string-vector-string-start-end"><code>(string-&gt;vector string [start [end]])</code></h3>
<p>The string-&gt;vector procedure returns a newly created vector initialized to the elements of the string string between start and end.</p>
<h3 id="string-append-string-..."><code>(string-append string ...)</code></h3>
<p>Returns a newly allocated string whose characters are the concatenation of the characters in the given strings.</p>
<h3 id="string-copy-string-start-end"><code>(string-copy string [start [end]])</code></h3>
<p>Returns a newly allocated copy of the part of the given string between start and end.</p>
<h3 id="string-copy-to-at-from-start-end"><code>(string-copy! to at from [start [end]])</code></h3>
<p>It is an error if at is less than zero or greater than the length of to. It is also an error if (- (string-length to) at) is less than (- end start).</p>
<p>Copies the characters of string from between start and end to string to, starting at at. The order in which characters are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary string and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<h3 id="string-fill-string-fill-start-end"><code>(string-fill! string fill [start [end]])</code></h3>
<p>It is an error if fill is not a character.</p>
<p>The string-fill! procedure stores fill in the elements of string between start and end.</p>
<h3 id="string-for-each-proc-string1-..."><code>(string-for-each proc string1 ...)</code></h3>
<p>It is an error if proc does not accept as many arguments as there are strings.</p>
<p>The arguments to string-for-each are like the arguments to string-map, but string-for-each calls proc for its side effects rather than for its values. Unlike string-map, string-for-each is guaranteed to call proc on the elements of the lists in order from the first element(s) to the last, and the value returned by string-for-each is unspecified. If more than one string is given and not all strings have the same length, string-for-each terminates when the shortest string runs out. It is an error for proc to mutate any of the strings.</p>
<h3 id="string-length-string"><code>(string-length string)</code></h3>
<p>Returns the number of characters in the given string.</p>
<h3 id="string-map-proc-string1-..."><code>(string-map proc string1 ...)</code></h3>
<p>It is an error if proc does not accept as many arguments as there are strings and return a single character.</p>
<p>The string-map procedure applies proc element-wise to the elements of the strings and returns a string of the results, in order. If more than one string is given and not all strings have the same length, string-map terminates when the shortest string runs out. The dynamic order in which proc is applied to the elements of the strings is unspecified. If multiple returns occur from string-map, the values returned by earlier returns are not mutated.</p>
<h3 id="string-ref-string-k"><code>(string-ref string k)</code></h3>
<p>It is an error if k is not a valid index of string.</p>
<p>The string-ref procedure returns character k of string using zero-origin indexing. There is no requirement for this procedure to execute in constant time.</p>
<h3 id="string-set-string-k-char"><code>(string-set! string k char)</code></h3>
<p>It is an error if k is not a valid index of string.</p>
<p>The string-set! procedure stores char in element k of string. There is no requirement for this procedure to execute in constant time.</p>
<h3 id="string"><code>string&lt;=?</code></h3>
<p>TODO</p>
<h3 id="string-1"><code>string&lt;?</code></h3>
<p>TODO</p>
<h3 id="string-string1-string2-..."><code>(string=? string1 string2 ...)</code></h3>
<p>Returns #t if all the strings are the same length and contain exactly the same characters in the same positions, otherwise returns #f.</p>
<h3 id="string-2"><code>string&gt;=?</code></h3>
<p>TODO</p>
<h3 id="string-3"><code>string&gt;?</code></h3>
<p>TODO</p>
<h3 id="string-obj"><code>(string? obj)</code></h3>
<p>Return <code>#t</code> if <code>OBJ</code> is string. Otherwise <code>#f</code>.</p>
<h3 id="substring-string-start-end"><code>(substring string start end)</code></h3>
<p>The substring procedure returns a newly allocated string formed from the characters of string beginning with index start and ending with index end. This is equivalent to calling string-copy with the same arguments, but is provided for backward compatibility and stylistic flexibility.</p>
<h3 id="symbol-string-symbol"><code>(symbol-&gt;string symbol)</code></h3>
<p>Returns the name of symbol as a string, but without adding escapes. It is an error to apply mutation procedures like string-set! to strings returned by this procedure.</p>
<h3 id="symbol-symbol1-symbol2-..."><code>(symbol=? symbol1 symbol2 ...)</code></h3>
<p>Returns #t if all the arguments are symbols and all have the same names in the sense of string=?.</p>
<h3 id="symbol-obj"><code>(symbol? obj)</code></h3>
<p>Returns #t if obj is a symbol, otherwise returns #f.</p>
<h3 id="syntax-error"><code>syntax-error</code></h3>
<p>TODO</p>
<h3 id="syntax-rules"><code>syntax-rules</code></h3>
<p>TODO</p>
<h3 id="textual-port"><code>textual-port?</code></h3>
<p>TODO</p>
<h3 id="truncate-x"><code>(truncate x)</code></h3>
<p>TODO</p>
<h3 id="truncate-quotient"><code>truncate-quotient</code></h3>
<p>TODO</p>
<h3 id="truncate-remainder"><code>truncate-remainder</code></h3>
<p>TODO</p>
<h3 id="truncate"><code>truncate/</code></h3>
<p>TODO</p>
<h3 id="u8-ready-port"><code>(u8-ready? [port])</code></h3>
<p>Returns #t if a byte is ready on the binary input port and returns #f otherwise. If u8-ready? returns #t then the next read-u8 operation on the given port is guaranteed not to hang. If the port is at end of file then u8-ready? returns #t.</p>
<h3 id="unless-test-expr-...-syntax"><code>(unless test expr ...)</code> syntax</h3>
<p>The test is evaluated, and if it evaluates to #f, the expressions are evaluated in order. The result of the unless expression is unspecified.</p>
<h3 id="unquote"><code>unquote</code></h3>
<p>TODO</p>
<h3 id="unquote-splicing"><code>unquote-splicing</code></h3>
<p>TODO</p>
<h3 id="utf8-string-bytevector-start-end"><code>(utf8-&gt;string bytevector [start [end]])</code></h3>
<p>It is an error for bytevector to contain invalid UTF-8 byte sequences.</p>
<p>The utf8-&gt;string procedure decodes the bytes of a bytevector between start and end and returns the corresponding string</p>
<h3 id="values-obj-..."><code>(values obj ...)</code></h3>
<p>Delivers all of its arguments to its continuation.</p>
<h3 id="vector-obj-..."><code>(vector obj ...)</code></h3>
<p>Returns a newly allocated vector whose elements contain the given arguments. It is analogous to list.</p>
<h3 id="vector-list-vector-start-end"><code>(vector-&gt;list vector [start [end]])</code></h3>
<p>The vector-&gt;list procedure returns a newly allocated list of the objects contained in the elements of vector between start and end. The list-&gt;vector procedure returns a newly created vector initialized to the elements of the list list.</p>
<h3 id="vector-string-vector-start-end"><code>(vector-&gt;string vector [start [end]])</code></h3>
<p>It is an error if any element of vector between start and end is not a character.</p>
<p>The vector-&gt;string procedure returns a newly allocated string of the objects contained in the elements of vector between start and end. The string-&gt;vector procedure returns a newly created vector initialized to the elements of the string string between start and end.</p>
<h3 id="vector-append-vector-..."><code>(vector-append vector ...)</code></h3>
<p>Returns a newly allocated vector whose elements are the concatenation of the elements of the given vectors.</p>
<h3 id="vector-copy-vector-start-end"><code>(vector-copy vector [start [end]])</code></h3>
<p>Returns a newly allocated copy of the elements of the given vector between start and end. The elements of the new vector are the same (in the sense of eqv?) as the elements of the old.</p>
<h3 id="vector-copy-to-at-from-start-end"><code>(vector-copy! to at from [start [end]])</code></h3>
<p>It is an error if at is less than zero or greater than the length of to. It is also an error if (- (vector-length to) at) is less than (- end start).</p>
<p>Copies the elements of vector from between start and end to vector to, starting at at. The order in which elements are copied is unspecified, except that if the source and destination overlap, copying takes place as if the source is first copied into a temporary vector and then into the destination. This can be achieved without allocating storage by making sure to copy in the correct direction in such circumstances.</p>
<h3 id="vector-fill-vector-fill-start-end"><code>(vector-fill! vector fill [start [end]])</code></h3>
<p>The vector-fill! procedure stores fill in the elements of vector between start and end.</p>
<h3 id="vector-for-each-proc-vector1-..."><code>(vector-for-each proc vector1 ...)</code></h3>
<p>It is an error if proc does not accept as many arguments as there are vectors.</p>
<p>The arguments to vector-for-each are like the arguments to vector-map, but vector-for-each calls proc for its side effects rather than for its values. Unlike vector-map, vector-for-each is guaranteed to call proc on the elements of the vectors in order from the first element(s) to the last, and the value returned by vector-for-each is unspecified. If more than one vector is given and not all vectors have the same length, vector-for-each terminates when the shortest vector runs out. It is an error for proc to mutate any of the vectors.</p>
<h3 id="vector-length-vector"><code>(vector-length vector)</code></h3>
<p>Returns the number of elements in vector as an exact integer.</p>
<h3 id="vector-map-proc-vector1-..."><code>(vector-map proc vector1 ...)</code></h3>
<p>It is an error if proc does not accept as many arguments as there are vectors and return a single value.</p>
<p>The vector-map procedure applies proc element-wise to the elements of the vectors and returns a vector of the results, in order. If more than one vector is given and not all vectors have the same length, vector-map terminates when the shortest vector runs out. The dynamic order in which proc is applied to the elements of the vectors is unspecified. If multiple returns occur from vector-map, the values returned by earlier returns are not mutated.</p>
<h3 id="vector-ref-vector-k"><code>(vector-ref vector k)</code></h3>
<p>It is an error if k is not a valid index of vector.</p>
<p>The vector-ref procedure returns the contents of element k of vector.</p>
<h3 id="vector-set-vector-k-obj"><code>(vector-set! vector k obj)</code></h3>
<p>It is an error if k is not a valid index of vector.</p>
<p>The vector-set! procedure stores obj in element k of vector.</p>
<h3 id="vector"><code>vector?</code></h3>
<p>Returns #t if obj is a bytevector. Otherwise, #f is returned.</p>
<h3 id="when-test-expr-...-syntax"><code>(when test expr ...)</code> syntax</h3>
<p>The test is evaluated, and if it evaluates to a true value, the expressions are evaluated in order. The result of the when expression is unspecified.</p>
<h3 id="with-exception-handler"><code>with-exception-handler</code></h3>
<p>TODO</p>
<h3 id="write-bytevector-bytevector-port-start-end"><code>(write-bytevector bytevector [port [start [end]]])</code></h3>
<p>Writes the bytes of bytevector from start to end in left-to-right order to the binary output port.</p>
<h3 id="write-char-char-port"><code>(write-char char [port])</code></h3>
<p>Writes the character char (not an external representation of the character) to the given textual output port and returns an unspecified value.</p>
<h3 id="write-string-string-port-start-end"><code>(write-string string [port [start [end]]])</code></h3>
<p>Writes the characters of string from start to end in left-to-right order to the textual output port.</p>
<h3 id="write-u8-byte-port"><code>(write-u8 byte [port])</code></h3>
<p>Writes the byte to the given binary output port and returns an unspecified value.</p>
<h3 id="zero-z"><code>(zero? z)</code></h3>
<p>Return <code>#t</code> if z is zero. Otherwise <code>#f</code>.</p>
